<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Percules Mesh Visualizer</title>
  <style>
    canvas { border: 1px solid #333; }
  </style>
</head>
<body>
  <h3>2D Bong Mesh</h3>
  <label for="waterHeight">Water Height (cm): </label>
  <input type="range" id="waterHeight" min="0" max="10" step="0.1" value="3">
  <span id="waterValue">3</span> cm
  <br><br>
  <canvas id="meshCanvas"></canvas>

  <script src="meshGenerator.js"></script>
  <script>
    const params = {
      tubeLengthCm: 10,
      tubeRadiusCm: 2,
      cellSizeMm: 1,
      percolatorConfig: { type: 'honeycomb', heightCm: 3, holeRadius: 1, rowSpacing: 4, colSpacing: 3 }
    };

    const waterInput = document.getElementById('waterHeight');
    const waterValue = document.getElementById('waterValue');
    const canvas = document.getElementById('meshCanvas');
    const ctx = canvas.getContext('2d');
    const scale = 5;

    function renderMesh() {
      params.waterHeightCm = parseFloat(waterInput.value);
      waterValue.textContent = waterInput.value;

      const { mesh: grid, probes } = buildMesh(params);
      const Nx = grid.length;
      const Ny = grid[0].length;
      canvas.width = Nx * scale;
      canvas.height = Ny * scale;

      const dx = params.cellSizeMm / 10;
      const waterHeightCells = Math.min(Ny - 1, Math.floor(params.waterHeightCm / dx));
      const jPlate = Math.floor(params.percolatorConfig.heightCm / dx);

      for (let i = 0; i < Nx; i++) {
        for (let j = 0; j < Ny; j++) {
          if (j === jPlate && grid[i][j] === FLUID) {
            ctx.fillStyle = '#FFCC66';        // percolator holes
          } else if (j < waterHeightCells && grid[i][j] === FLUID) {
            ctx.fillStyle = '#4DA6FF';        // water
          } else if (grid[i][j] === FLUID) {
            ctx.fillStyle = '#99CC99';        // air
          } else {
            ctx.fillStyle = '#999';           // glass
          }
          ctx.fillRect(i * scale, canvas.height - (j + 1) * scale, scale, scale);
        }
      }

      // plate line
      const yPlate = canvas.height - jPlate * scale;
      ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(0, yPlate); ctx.lineTo(canvas.width, yPlate); ctx.stroke();

      // probes
      const { inlet, bubble, mic } = probes;
      [{pt: inlet, color: 'green', label: 'I'}, {pt: bubble, color: 'orange', label: 'B'}, {pt: mic, color: 'red', label: 'M'}]
        .forEach(({pt, color, label}) => {
          const x = pt.i * scale;
          const y = canvas.height - (pt.j + 1) * scale;
          ctx.fillStyle = color;
          ctx.fillRect(x, y, scale, scale);
          ctx.fillStyle = '#fff'; ctx.font = `${scale}px sans-serif`;
          ctx.fillText(label, x + 1, y + scale - 1);
        });

      // assertions
      function assertProbe(name, {i, j}) {
        if (i < 0 || i >= Nx || j < 0 || j >= Ny) throw new Error(`${name} probe out of bounds`);
        if (name !== 'mic' && grid[i][j] !== FLUID) throw new Error(`${name} probe not in FLUID cell`);
        console.log(`${name} probe OK at (${i},${j})`);
      }
      try {
        assertProbe('inlet', probes.inlet);
        assertProbe('bubble', probes.bubble);
        assertProbe('mic', probes.mic);
      } catch (e) {
        console.error(e.message);
      }
    }

    waterInput.addEventListener('input', renderMesh);
    renderMesh();
  </script>
</body>
</html>
